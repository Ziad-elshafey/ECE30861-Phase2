#!/bin/bash
#
# Executable entry point - Bash version (cross-platform)
#

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR"

# Detect OS and set Python command
if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "win32" || "$OSTYPE" == "cygwin" ]]; then
    # Windows (Git Bash, MSYS2, Cygwin)
    PYTHON_CMD="python"
elif command -v python3 &> /dev/null; then
    # macOS/Linux with python3
    PYTHON_CMD="python3"
elif command -v python &> /dev/null; then
    # Fallback to python
    PYTHON_CMD="python"
else
    echo "Error: Python not found. Please install Python 3.7 or higher." >&2
    exit 1
fi

# Function to show usage
show_usage() {
    echo "Usage: $0 <command>" >&2
    echo "Commands:" >&2
    echo "  install        - Install dependencies" >&2
    echo "  test          - Run test suite" >&2
    echo "  <URL_FILE>    - Process URLs from file" >&2
    exit 1
}

# Function to install dependencies
install_deps() {
    echo "Installing dependencies..."
    if $PYTHON_CMD -m pip install -r "$PROJECT_ROOT/requirements.txt"; then
        echo "Dependencies installed successfully."
        exit 0
    else
        echo "Failed to install dependencies" >&2
        exit 1
    fi
}

# Function to run tests (converted from Python run_tests function)
run_tests() {
    echo "Running test suite..."
    cd "$PROJECT_ROOT"
    
    # Use Python to run tests and get reliable cross-platform results
    $PYTHON_CMD -c "
import sys
import subprocess
import re
import os

sys.path.insert(0, '.')

# Validate environment
try:
    from src.cli import _validate_environment
    _validate_environment()
except Exception as e:
    print(f'Environment validation failed: {e}', file=sys.stderr)
    sys.exit(1)

# Run pytest with coverage
print('Running pytest with coverage...', flush=True)
result = subprocess.run(
    [sys.executable, '-m', 'pytest', '--cov=src', '--cov-report=term-missing', '--tb=short'],
    capture_output=True,
    text=True
)

output = result.stdout + result.stderr

# Print full output for debugging
print(output, flush=True)

# Parse test results
passed = failed = errors = 0
coverage_pct = 0

# Extract test counts
for line in output.split('\n'):
    # Look for pytest summary line (e.g., '134 passed, 10 failed in 5.23s')
    if 'passed' in line or 'failed' in line or 'error' in line:
        passed_match = re.search(r'(\d+)\s+passed', line)
        failed_match = re.search(r'(\d+)\s+failed', line)
        error_match = re.search(r'(\d+)\s+error', line)
        
        if passed_match:
            passed = int(passed_match.group(1))
        if failed_match:
            failed = int(failed_match.group(1))
        if error_match:
            errors = int(error_match.group(1))
    
    # Extract coverage percentage from TOTAL line
    if 'TOTAL' in line and '%' in line:
        # Match percentage in coverage output (e.g., 'TOTAL  1234  567  123  45%')
        pct_match = re.search(r'(\d+)%', line)
        if pct_match:
            coverage_pct = int(pct_match.group(1))

total = passed + failed + errors

# Print formatted output
print(f'{passed}/{total} test cases passed. {coverage_pct}% line coverage achieved.')

# Exit with appropriate code
if result.returncode != 0 or coverage_pct < 80:
    sys.exit(1)
else:
    sys.exit(0)
"
    exit $?
}

# Function to process URLs
process_urls() {
    local url_file="$1"
    
    # Check if file exists
    if [[ ! -f "$url_file" ]]; then
        echo "Error: URL file '$url_file' does not exist." >&2
        exit 1
    fi
    
    # Create a log file for all non-JSON output
    log_file="processing_log_$(date +%Y%m%d_%H%M%S).txt"
    
    cd "$PROJECT_ROOT"
    
    # Run Python script - stdout contains only JSON, stderr goes to log file
    if $PYTHON_CMD -c "
import sys
sys.path.insert(0, '.')
from src.cli import _validate_environment, process_urls
_validate_environment()
process_urls('$url_file')
" 2>"$log_file"; then
        # Success - JSON was output to stdout, log info goes to stderr
        exit 0
    else
        # Failure - error info is in log file
        echo "URL processing failed. Check log file: $log_file" >&2
        exit 1
    fi
}

# Main script logic
main() {
    # Check if at least one argument is provided
    if [[ $# -lt 1 ]]; then
        show_usage
    fi
    
    local command="$1"
    
    case "$command" in
        "install")
            install_deps
            ;;
        "test")
            run_tests
            ;;
        *)
            # Treat as URL file path
            process_urls "$command"
            ;;
    esac
}

# Run main function with all arguments
main "$@"