#!/bin/bash
#
# Executable entry point - Bash version
#

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR"

# Function to show usage
show_usage() {
    echo "Usage: $0 <command>" >&2
    echo "Commands:" >&2
    echo "  install        - Install dependencies" >&2
    echo "  test          - Run test suite" >&2
    echo "  <URL_FILE>    - Process URLs from file" >&2
    exit 1
}

# Function to install dependencies
install_deps() {
    echo "Installing dependencies..."
    if python3 -m pip install -r "$PROJECT_ROOT/requirements.txt"; then
        echo "Dependencies installed successfully."
        exit 0
    else
        echo "Failed to install dependencies" >&2
        exit 1
    fi
}

# Function to run tests (converted from Python run_tests function)
run_tests() {
    echo "Running test suite..."
    cd "$PROJECT_ROOT"
    
    # Validate environment variables at startup (consistent with CLI command)
    if ! python3 -c "
import sys
sys.path.insert(0, '.')
from src.cli import _validate_environment
_validate_environment()
"; then
        echo "Environment validation failed" >&2
        exit 1
    fi
    
    # Run pytest with coverage and capture output
    echo "Running pytest with coverage..."
    if ! pytest_output=$(python3 -m pytest --cov=src --cov-report=term-missing --tb=short 2>&1); then
        pytest_exit_code=$?
    else
        pytest_exit_code=0
    fi
    
    # Parse test results
    test_summary=""
    coverage_summary=""
    passed=0
    failed=0
    errors=0
    total=0
    coverage=0
    
    # Look for test summary line
    while IFS= read -r line; do
        # Look for test summary - handle different pytest output formats
        if [[ ("$line" == *"passed"* && ("$line" == *"failed"* || "$line" == *"error"*)) || "$line" == *"test session starts"* ]]; then
            test_summary="$line"
        elif [[ "$line" == *"TOTAL"* && "$line" == *"%"* ]]; then
            # Extract coverage percentage
            for part in $line; do
                if [[ "$part" == *"%" ]]; then
                    coverage_summary="${part%\%}"
                    break
                fi
            done
        fi
    done <<< "$pytest_output"
    
    # Parse numbers from pytest output using grep and regex
    if [[ -n "$test_summary" ]]; then
        # Try multiple patterns to match different pytest output formats
        passed=$(echo "$test_summary" | grep -oE '[0-9]+ passed' | grep -oE '[0-9]+' || echo "0")
        failed=$(echo "$test_summary" | grep -oE '[0-9]+ failed' | grep -oE '[0-9]+' || echo "0")
        errors=$(echo "$test_summary" | grep -oE '[0-9]+ error' | grep -oE '[0-9]+' || echo "0")
        
        # Also try to find test counts in other formats
        if [[ "$passed" == "0" ]]; then
            passed=$(echo "$pytest_output" | grep -oE '[0-9]+ passed' | grep -oE '[0-9]+' | head -1 || echo "0")
        fi
        if [[ "$failed" == "0" ]]; then
            failed=$(echo "$pytest_output" | grep -oE '[0-9]+ failed' | grep -oE '[0-9]+' | head -1 || echo "0")
        fi
        if [[ "$errors" == "0" ]]; then
            errors=$(echo "$pytest_output" | grep -oE '[0-9]+ error' | grep -oE '[0-9]+' | head -1 || echo "0")
        fi
        
        # Convert to integers
        passed=$((passed))
        failed=$((failed))
        errors=$((errors))
        total=$((passed + failed + errors))
    fi
    
    # Format coverage as integer
    if [[ -n "$coverage_summary" ]]; then
        coverage=$(printf "%.0f" "$coverage_summary")
    fi
    
    # Format output as required
    echo "${passed}/${total} test cases passed. ${coverage}% line coverage achieved."
    
    # Exit with error if tests failed OR coverage < 80%
    if [[ $pytest_exit_code -ne 0 || $coverage -lt 80 ]]; then
        exit 1
    else
        exit 0
    fi
}

# Function to process URLs
process_urls() {
    local url_file="$1"
    
    # Check if file exists
    if [[ ! -f "$url_file" ]]; then
        echo "Error: URL file '$url_file' does not exist." >&2
        exit 1
    fi
    
    # Create a log file for all non-JSON output
    log_file="processing_log_$(date +%Y%m%d_%H%M%S).txt"
    
    cd "$PROJECT_ROOT"
    
    # Run Python script - stdout contains only JSON, stderr goes to log file
    if python3 -c "
import sys
sys.path.insert(0, '.')
from src.cli import _validate_environment, process_urls
_validate_environment()
process_urls('$url_file')
" 2>"$log_file"; then
        # Success - JSON was output to stdout, log info goes to stderr
        exit 0
    else
        # Failure - error info is in log file
        echo "URL processing failed. Check log file: $log_file" >&2
        exit 1
    fi
}

# Main script logic
main() {
    # Check if at least one argument is provided
    if [[ $# -lt 1 ]]; then
        show_usage
    fi
    
    local command="$1"
    
    case "$command" in
        "install")
            install_deps
            ;;
        "test")
            run_tests
            ;;
        *)
            # Treat as URL file path
            process_urls "$command"
            ;;
    esac
}

# Run main function with all arguments
main "$@"